# 交易撮合引擎测试指南

## 🎯 功能概述

交易撮合引擎实现了自动匹配买卖单的功能，遵循以下原则：
1. **价格优先**：买单价格从高到低，卖单价格从低到高
2. **时间优先**：相同价格按时间先后顺序
3. **自动撮合**：每5秒自动执行一次撮合任务

---

## ✅ 已实现功能

### 1. 数据库扩展
- ✅ `trade_order` 表新增字段：
  - `matched_order_id` - 匹配的订单ID
  - `match_time` - 成交时间
  - `final_price` - 最终成交价

### 2. 资产校验服务
- ✅ 创建 `AssetFeignClient` - Feign客户端
- ✅ 实现 `AssetsValidationController` - 资产校验接口
- ✅ 卖单发布前校验用户资产是否足够

### 3. 自动撮合服务
- ✅ `TradeMatchService` - 核心撮合算法
  - 价格优先、时间优先排序
  - 支持部分成交
  - 支持QUOTA和CREDIT两种资产类型
  - 防止自己和自己交易

### 4. 定时任务
- ✅ `TradeMatchScheduler` - 定时调度器
  - 每5秒执行一次自动撮合
  - 可选：每分钟清理过期订单

### 5. Controller增强
- ✅ `TradeOrderController` - 订单发布增加资产校验
  - 卖单校验资产充足性
  - 详细的日志记录

---

## 🧪 测试步骤

### 准备工作

#### 1. 更新数据库表结构
```sql
-- 在 MySQL 中执行
USE carbon_trade;

-- 如果表已存在，添加新字段
ALTER TABLE trade_order 
ADD COLUMN matched_order_id BIGINT(20) DEFAULT NULL COMMENT '匹配的订单ID',
ADD COLUMN match_time DATETIME DEFAULT NULL COMMENT '成交时间',
ADD COLUMN final_price DECIMAL(20, 2) DEFAULT NULL COMMENT '最终成交价';

-- 添加索引
ALTER TABLE trade_order
ADD KEY idx_status (status),
ADD KEY idx_item_type (item_type),
ADD KEY idx_direction (direction);
```

或者删除重建：
```sql
DROP TABLE IF EXISTS trade_order;
-- 然后运行 init.sql
```

#### 2. 插入测试数据
```bash
mysql -u root -p carbon_trade < service-trade/src/main/resources/test_match_data.sql
```

#### 3. 启动服务
```bash
# 启动 service-assets（端口8082）
cd service-assets
mvn spring-boot:run

# 启动 service-trade（端口8084）
cd service-trade
mvn spring-boot:run
```

---

### 测试场景

#### 场景1：完全匹配
**预期结果**：买单和卖单完全成交

**查询SQL**：
```sql
SELECT id, user_id, direction, price, quantity, traded_quantity, status, 
       matched_order_id, match_time, final_price
FROM trade_order
WHERE item_type = 'QUOTA' AND price = 50.00
ORDER BY id;
```

**验证点**：
- ✅ 两个订单status都变为 `CLOSED`
- ✅ `traded_quantity` = `quantity`
- ✅ `match_time` 不为空
- ✅ `final_price` = 50.00（卖单价格）

---

#### 场景2：价格优先（买单价格 > 卖单价格）
**预期结果**：买单60元 >= 卖单55元，应该成交，成交价为55元

**查询SQL**：
```sql
SELECT id, user_id, direction, price, quantity, traded_quantity, status, final_price
FROM trade_order
WHERE item_type = 'CREDIT' AND (price = 60.00 OR price = 55.00)
ORDER BY id;
```

**验证点**：
- ✅ 买单和卖单都部分或全部成交
- ✅ `final_price` = 55.00（取卖单价格）
- ✅ 成交数量 = min(买单数量, 卖单数量) = 150吨

---

#### 场景3：部分成交
**预期结果**：买单500吨 > 卖单200吨，卖单全部成交，买单部分成交

**查询SQL**：
```sql
SELECT id, user_id, direction, price, quantity, traded_quantity, status
FROM trade_order
WHERE item_type = 'QUOTA' AND ((direction = 'BUY' AND price = 48.00) OR (direction = 'SELL' AND price = 45.00))
ORDER BY id;
```

**验证点**：
- ✅ 卖单：`traded_quantity` = 200, `status` = 'CLOSED'
- ✅ 买单：`traded_quantity` = 200, `status` = 'OPEN'（还有300吨未成交）

---

#### 场景4：无法成交
**预期结果**：买单40元 < 卖单50元，无法成交

**查询SQL**：
```sql
SELECT id, user_id, direction, price, quantity, traded_quantity, status
FROM trade_order
WHERE item_type = 'CREDIT' AND (price = 40.00 OR price = 50.00)
AND direction IN ('BUY', 'SELL')
ORDER BY id DESC
LIMIT 2;
```

**验证点**：
- ✅ 两个订单status都是 `OPEN`
- ✅ `traded_quantity` = 0
- ✅ `match_time` 为空

---

#### 场景5：时间优先
**预期结果**：多个卖单价格相同，优先匹配时间早的

**查询SQL**：
```sql
SELECT id, user_id, direction, price, quantity, traded_quantity, status, create_time, match_time
FROM trade_order
WHERE item_type = 'QUOTA' AND ((direction = 'BUY' AND price = 52.00) OR (direction = 'SELL' AND price = 50.00))
ORDER BY create_time;
```

**验证点**：
- ✅ 最早的卖单优先成交
- ✅ 买单部分成交200吨（匹配两个卖单）

---

#### 场景6：多次部分成交
**预期结果**：一个卖单可以匹配多个买单

**查询SQL**：
```sql
SELECT id, user_id, direction, price, quantity, traded_quantity, status, matched_order_id
FROM trade_order
WHERE item_type = 'CREDIT' AND 
      ((direction = 'BUY' AND price IN (55.00, 54.00)) OR (direction = 'SELL' AND price = 52.00))
ORDER BY direction, price DESC;
```

**验证点**：
- ✅ 卖单250吨全部成交
- ✅ 买单1（55元）全部成交150吨
- ✅ 买单2（54元）部分成交100吨

---

## 📊 监控和日志

### 查看撮合日志
```bash
# 查看service-trade日志
tail -f logs/service-trade.log | grep "撮合"
```

**关键日志**：
- `开始执行交易撮合...`
- `撮合成功：买单ID=xx, 卖单ID=xx, 数量=xx, 价格=xx`
- `交易撮合执行完毕`

### 监控SQL
```sql
-- 查看所有成交订单
SELECT id, user_id, direction, item_type, price, quantity, traded_quantity, 
       status, matched_order_id, match_time, final_price
FROM trade_order
WHERE status = 'CLOSED'
ORDER BY match_time DESC;

-- 统计成交情况
SELECT 
    item_type,
    COUNT(*) as total_orders,
    SUM(CASE WHEN status = 'CLOSED' THEN 1 ELSE 0 END) as closed_orders,
    SUM(CASE WHEN status = 'OPEN' THEN 1 ELSE 0 END) as open_orders,
    SUM(traded_quantity) as total_traded
FROM trade_order
GROUP BY item_type;
```

---

## 🔧 API测试

### 1. 发布买单（带资产校验）
```bash
curl -X POST http://localhost:8084/api/trade/orders/publish \
  -H "Content-Type: application/json" \
  -d '{
    "userId": 1,
    "itemType": "QUOTA",
    "direction": "BUY",
    "price": 50.00,
    "quantity": 100.00
  }'
```

### 2. 发布卖单（会校验资产）
```bash
curl -X POST http://localhost:8084/api/trade/orders/publish \
  -H "Content-Type: application/json" \
  -d '{
    "userId": 2,
    "itemType": "QUOTA",
    "direction": "SELL",
    "price": 48.00,
    "quantity": 50.00
  }'
```

**预期**：
- 如果用户2没有足够的QUOTA资产，会返回错误
- 如果资产充足，订单发布成功

### 3. 查询市场挂单
```bash
curl "http://localhost:8084/api/trade/orders/market?page=1&size=10&type=QUOTA"
```

### 4. 测试资产校验接口
```bash
curl "http://localhost:8082/api/assets/validate?userId=1&assetType=QUOTA&quantity=100"
```

---

## ✅ 验收标准

### 功能验收
- ✅ 买单价格 >= 卖单价格时自动成交
- ✅ 成交价格取卖单价格
- ✅ 支持部分成交
- ✅ 价格优先、时间优先原则正确
- ✅ 不同资产类型独立撮合
- ✅ 防止自己和自己交易

### 性能验收
- ✅ 撮合任务执行时间 < 1秒（订单数 < 1000）
- ✅ 定时任务正常运行，无阻塞
- ✅ 数据库查询使用索引

### 安全验收
- ✅ 卖单发布前校验资产
- ✅ Feign调用有降级处理
- ✅ 撮合过程使用事务

---

## 🐛 已知限制

1. **账户余额更新**：目前只更新订单状态，未实现账户余额和资产持仓的更新（标记为TODO）
2. **撤单功能**：未实现订单撤销功能
3. **订单过期**：未实现订单过期自动关闭
4. **手续费**：未实现交易手续费计算

---

## 📈 下一步优化

1. **完善账户服务调用**
   - 成交后更新买方和卖方的账户余额
   - 更新买方和卖方的资产持仓

2. **订单管理**
   - 实现订单撤销功能
   - 实现订单过期自动关闭
   - 增加订单有效期设置

3. **交易记录**
   - 创建 `trade_record` 表记录每笔成交
   - 支持成交历史查询

4. **性能优化**
   - 增加Redis缓存减少数据库查询
   - 使用消息队列异步处理撮合结果

---

## 📞 问题排查

### 1. 撮合不执行
- 检查 `@EnableScheduling` 是否启用
- 查看日志是否有异常
- 确认数据库中有OPEN状态的订单

### 2. Feign调用失败
- 检查 service-assets 是否启动
- 查看Nacos中服务是否注册成功
- 检查端口和网络连接

### 3. 资产校验总是失败
- 检查数据库中是否有用户的资产数据
- 查看 service-assets 的日志
- 测试资产校验API是否正常

---

**测试完成后，请填写测试报告并更新开发进度文档！**
